<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Demonlist</title>
    <link rel="icon" href="images/websiteicon.ico" type="image/x-icon">
  <style>
body {
  background-color: #00112d;
  background-image: url('images/main.png');
  background-size: auto 100%;
  background-position: left center;
  background-attachment: fixed;
  background-repeat: no-repeat;
  color: #fff;
  font-family: 'Montserrat', sans-serif;
  margin: 0;
  padding: 0;
  line-height: 1.6;
  padding-top: 70px;
  min-height: 100vh;
  overflow-x: hidden;
}

@media (min-width: 1920px) {
  body {
    background-size: 100% auto;
    background-position: center center;
  }
}

    a {
      color: inherit;
      text-decoration: none;
      transition: color 0.3s ease;
    }

    a:hover {
      color: #aaa;
    }

.compact-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 70px;
  background: #111827;
  display: flex;
  align-items: center;
  padding: 0 25px;
  box-shadow: 0 2px 15px rgba(0, 0, 0, 0.6);
  z-index: 1000;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  justify-content: space-between;
}

.header-left {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
}

.header-right {
  display: flex;
  align-items: center;
  margin-left: 20px;
}

.search-container {
  flex-grow: 1;
  max-width: 550px;
  margin: 0 25px;
  min-width: 150px;
}

.header-title {
  font-size: 1.9em;
  font-weight: 700;
  margin-right: 30px;
  color: #fff;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
  white-space: nowrap;
}

.dropdown {
  position: relative;
  display: inline-block;
  margin-right: 20px;
}

.dropbtn {
  background: transparent;
  color: rgba(255, 255, 255, 0.6);
  border: none;
  padding: 10px 15px;
  font-size: 1em;
  cursor: pointer;
  min-width: auto;
  text-align: center;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
  height: auto;
  box-sizing: border-box;
  white-space: nowrap;
}

.dropdown-arrow {
  margin-left: 3px; 
  font-size: 0.7em;
  color: #fff;
  transition: all 0.2s ease;
  position: relative;
  top: 2px; 
} 

.dropbtn:hover, 
.dropbtn:hover .dropdown-arrow,
.dropbtn:hover .fa-layer-group {
  color: #fff;
}

.fa-layer-group {
  color: rgba(255, 255, 255, 0.6);
  transition: all 0.2s ease;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #1f2937;
  min-width: 160px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  z-index: 1;
  border-radius: 6px;
  overflow: hidden;
  border: none;
  top: 100%;
  left: 0;
}

.dropdown-content a {
  color: #fff;
  padding: 10px 16px;
  text-decoration: none;
  display: block;
  transition: background-color 0.2s;
  font-size: 0.95em;
}

.dropdown-content a:hover {
  background-color: #374151;
}

.search-container {
  flex-grow: 1;
  max-width: 550px;
  margin: 0 25px;
}

.search-input-wrapper {
  position: relative;
  display: flex;
  align-items: center;
}

#search-input {
  background: #374151;
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.4);
  padding: 12px 45px 12px 20px;
  font-size: 1em;
  border-radius: 6px;
  width: 100%;
  transition: all 0.3s ease;
}

    #search-input:focus {
      border-color: #ff4d4d;
      box-shadow: 0 0 0 2px rgba(255, 77, 77, 0.3);
      outline: none;
    }

    #search-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

.roulette-btn {
  background: linear-gradient(135deg, #8a2387, #e94057, #f27121);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 12px 25px;
  font-size: 1em;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-left: 30px;
  box-shadow: 0 4px 15px rgba(226, 67, 93, 0.3);
  position: relative;
  overflow: hidden;
}

.roulette-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  transition: all 0.5s ease;
}

.roulette-btn:hover::before {
  left: 100%;
}

.roulette-btn i {
  margin-right: 10px;
  font-size: 1.2em;
  transition: transform 0.3s ease;
}

.roulette-btn:hover i {
  transform: rotate(15deg);
}

    .level-container {
      display: flex;
      flex-direction: column;
      width: 85%;
      max-width: 1000px;
      margin: 25px auto;
      padding: 0 15px;
    }

.level {
  display: flex;
  align-items: center;
  background-color: #1f2937;
  border: 1px solid #353f4f;
  margin-bottom: 12px;
  padding: 12px;
  border-radius: 8px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  position: relative;
  transform: scale(1);
  will-change: transform;
}

.level:hover {
  background-color: #374151;
  transform: scale(1.05);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
  z-index: 10;
}

    .level-preview {
      width: 25%;
      margin-right: 15px;
      flex-shrink: 0;
    }

    .level-preview a {
      display: block;
    }

    .level-preview img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 6px;
      object-fit: cover;
      aspect-ratio: 16 / 9;
      border: 1px solid rgba(0, 0, 0, 0.3);
    }

    .level-info {
      width: 75%;
      padding-right: 20px;
    }

.level-title {
  font-size: 1.35em;
  margin: 0 0 6px 0;
  color: #eee;
  font-family: 'Montserrat', sans-serif;
  font-weight: 600; 
}

.level-author,
.level-verifier {
  font-size: 1.05em;
  margin: 0;
  color: #ccc;
}

.level-id {
  position: absolute;
  bottom: 12px;
  right: 12px;
  font-size: 0.9em;
  color: #999;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  background-color: rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
  font-family: 'Courier New', monospace;
}

    .level-id:hover {
      background-color: rgba(0, 0, 0, 0.4);
      color: #ddd;
    }

    .show-in-list {
      position: absolute;
      bottom: 12px;
      right: 130px;
      font-size: 0.9em;
      color: #fff;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 4px;
      background-color: #555;
      border: 1px solid #666;
      transition: all 0.3s ease;
      display: none;
    }

    .show-in-list:hover {
      background-color: #666;
      transform: translateY(-1px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .search-active .show-in-list {
      display: block;
    }

.scroll-to-top {
  position: fixed;
  bottom: 40px;
  right: 40px;
  width: 56px;
  height: 56px;
  background: linear-gradient(135deg, #1e88e5, #0d47a1);
  border: none;
  border-radius: 50%;
  color: white;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 4px 30px rgba(33, 150, 243, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  z-index: 999;
  transform: scale(0.8);
  overflow: hidden;
  outline: none;
}

.scroll-to-top::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.1) 100%);
  transform: translateX(-100%) skewX(-20deg);
  transition: transform 0.6s ease;
}

.scroll-to-top:hover::before {
  transform: translateX(100%) skewX(-20deg);
}

.scroll-to-top:hover {
  box-shadow: 0 6px 30px rgba(33, 150, 243, 0.7);
}

.scroll-to-top.visible {
  opacity: 1;
  visibility: visible;
  transform: scale(1);
}

.scroll-to-top:hover.visible {
  transform: scale(1.05);
}

.scroll-to-top:active {
  transform: scale(0.95) !important;
}

.scroll-to-top .fa-arrow-up {
  transition: transform 0.2s ease;
}

.scroll-to-top:active .fa-arrow-up {
  transform: translateY(-4px);
}

.filters-btn {
  position: fixed;
  top: 100px;
  right: 40px;
  left: auto;
  width: 56px;
  height: 56px;
  background: linear-gradient(135deg, #8a2387, #e94057);
  border: none;
  border-radius: 50%;
  color: white;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 4px 30px rgba(233, 64, 87, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
  visibility: visible;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  z-index: 999;
  transform: scale(1);
  overflow: hidden;
  outline: none;
}

.filters-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.1) 100%);
  transform: translateX(-100%) skewX(-20deg);
  transition: transform 0.6s ease;
}

.filters-btn:hover::before {
  transform: translateX(100%) skewX(-20deg);
}

.filters-btn:hover {
  box-shadow: 0 6px 30px rgba(233, 64, 87, 0.7);
}

.filters-btn.visible {
  opacity: 1;
  visibility: visible;
  transform: scale(1);
}

.filters-btn:hover.visible {
  transform: scale(1.05);
}

.filters-btn:active {
  transform: scale(0.95) !important;
}

.filter-group {
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.level-preview img,
.roulette-level-preview img {
  background-color: #444;
  background-image: linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333),
                  linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333);
  background-size: 20px 20px;
  background-position: 0 0, 10px 10px;
  transition: opacity 0.3s ease;
  object-fit: cover;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.level-preview img[data-src],
.roulette-level-preview img[data-src] {
  opacity: 0;
}

.level-preview img.loaded,
.roulette-level-preview img.loaded {
  opacity: 1;
}

.level-crown-container {
  position: absolute;
  top: 15px;
  right: 15px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.level-crown-container:hover {
  transform: scale(1.1);
}

.level-new-container {
  position: absolute;
  top: 15px;
  right: 50px;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  cursor: pointer;
}

.level-new-container.compact {
  position: static;
  margin-left: auto;
  margin-right: 8px;
  width: 20px;
  height: 20px;
}

.level-new-container img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.roulette-level .level-crown-container {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.roulette-level .level-crown-container:hover {
    transform: scale(1.1);
}

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
      background-color: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      transition: background-color 0.3s ease;
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal.active {
      display: flex;
      opacity: 1;
    }

    .modal-content {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      width: 90%;
      max-width: 500px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      padding: 25px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      transform: translateY(0);
      transition: none;
    }

    .modal-header {
      margin-bottom: 20px;
      text-align: center;
    }

    .modal-title {
      font-size: 1.8em;
      margin: 0;
      color: #fff;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      background: linear-gradient(to right, #8a2387, #e94057, #f27121);
background-clip: text;
-webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

.modal-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(255,255,255,0.15);
    border: none;
    color: #fff;
    font-size: 1em;
    cursor: pointer;
    transition: all 0.3s ease;
    border-radius: 50%;
    width: 26px;
    height: 26px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    background: rgba(255,255,255,0.2);
    color: #fff;
    transform: rotate(90deg);
}

    .modal-close:hover {
      color: #fff;
    }

.modal-body {
  padding: 0 10px 10px;
  color: #ccc;
  font-size: 1.1em;
  line-height: 1.5;
}

.modal-footer {
  display: flex;
  justify-content: space-between;
  margin-top: 20px;
}

.modal-btn {
  transition: all 0.2s ease;
}

.modal-btn:hover {
  transform: translateY(-2px);
}

.roulette-modal-content {
    max-width: 500px;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
}

.roulette-modal-header {
    background: linear-gradient(135deg, #8a2387 0%, #e94057 50%, #f27121 100%);
    padding: 20px;
    margin: -25px -25px 20px -25px;
    border-radius: 12px 12px 0 0;
}

.roulette-modal-title {
    color: #fff !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    -webkit-text-fill-color: #fff !important;
    background: none !important;
    text-align: center;
    font-size: 1.8em;
    margin: 0;
}

.roulette-settings-container {
    margin: 20px 0;
}

.roulette-setting-group {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.roulette-setting-group:hover {
    border-color: rgba(255, 255, 255, 0.3);
    background: rgba(0, 0, 0, 0.3);
}

.roulette-setting-label {
    color: #fff;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    font-size: 1.05em;
}

.roulette-checkbox-container {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.roulette-checkbox-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    position: relative;
    padding-left: 30px;
    margin-bottom: 0;
    color: #ccc;
    transition: color 0.3s ease;
}

.roulette-checkbox-label:hover {
    color: #fff;
}

.roulette-checkbox-label input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
}

.roulette-checkbox-custom {
    position: absolute;
    top: 0;
    left: 0;
    height: 20px;
    width: 20px;
    background-color: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    transition: all 0.3s ease;
}

.roulette-checkbox-label:hover .roulette-checkbox-custom {
    border-color: rgba(255, 255, 255, 0.5);
}

.roulette-checkbox-label input:checked ~ .roulette-checkbox-custom {
    background-color: #e94057;
    border-color: #e94057;
}

.roulette-checkbox-custom:after {
    content: "";
    position: absolute;
    display: none;
    left: 7px;
    top: 3px;
    width: 5px;
    height: 10px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
}

.roulette-checkbox-label input:checked ~ .roulette-checkbox-custom:after {
    display: block;
}

.roulette-ranges-container {
    display: flex;
    gap: 15px;
    justify-content: space-between;
    margin-bottom: 25px; 
}

.roulette-ranges-container .roulette-setting-group {
    flex: 1;
    margin-bottom: 0;
}

.roulette-range-inputs {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.roulette-range-input {
    width: 100%;
}

.roulette-range-input label {
    display: block;
    margin-bottom: 5px;
    color: #aaa;
    font-size: 0.9em;
}

.roulette-range-input input {
    width: calc(100% - 30px); 
    max-width: 120px; 
    padding: 10px 15px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    font-size: 1em;
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.no-spinners {
    -moz-appearance: textfield; 
    appearance: textfield;
}

.no-spinners::-webkit-outer-spin-button,
.no-spinners::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

.roulette-range-input input:focus {
    border-color: #e94057;
    box-shadow: 0 0 0 2px rgba(233, 64, 87, 0.3);
    outline: none;
}

.roulette-settings-options {
    display: flex;
    flex-direction: column;
    gap: 5px; 
}

.roulette-skip-container {
    display: flex;
    align-items: center;
    width: 100%;
    margin-bottom: 5px;
}

#skip-count {
    width: 180px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    padding: 8px 12px;
    font-size: 0.9em;
    margin-left: auto;
    transition: all 0.3s ease;
}

#skip-count:focus {
    border-color: #e94057;
    box-shadow: 0 0 0 2px rgba(233, 64, 87, 0.3);
    outline: none;
}

.roulette-spin-btn {
    display: block;
    width: 100%;
    padding: 15px;
    background: linear-gradient(135deg, #8a2387, #e94057, #f27121);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1.1em;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 10px;
    text-transform: none;
    letter-spacing: normal;
    position: relative;
    overflow: hidden;
    z-index: 1;
}

.roulette-spin-btn::before {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    width: calc(100% + 20px);
    height: calc(100% + 20px);
    background: linear-gradient(
        135deg, 
        rgba(255,255,255,0) 0%,
        rgba(255,255,255,0.1) 25%,
        rgba(255,255,255,0.05) 50%,
        rgba(255,255,255,0.1) 75%,
        rgba(255,255,255,0) 100%
    );
    transform: translateX(-100%) skew(-20deg);
    transition: transform 0.6s ease;
    z-index: -1;
}

.roulette-spin-btn:hover::before {
    transform: translateX(100%) skew(-20deg);
}

.roulette-spin-btn:active::before {
    background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1), rgba(255,255,255,0.2));
}

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 1.1em;
      color: #ccc;
    }

    .form-group select,
    .form-group input {
      width: 100%;
      padding: 12px 15px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(0, 0, 0, 0.25);
      color: #fff;
      font-size: 1em;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #e94057;
      box-shadow: 0 0 0 2px rgba(233, 64, 87, 0.3);
    }

    .range-inputs {
      display: flex;
      gap: 10px;
    }

    .range-inputs input {
      flex: 1;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      margin-top: 10px;
    }

    .checkbox-group input {
      width: auto;
      margin-right: 10px;
      accent-color: #e94057;
    }

    .checkbox-group label {
      margin-bottom: 0;
      cursor: pointer;
    }

    .modal-btn {
      display: block;
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #8a2387, #e94057);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 1.1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 15px;
    }

    .modal-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(233, 64, 87, 0.4);
    }

    .roulette-section {
      width: 85%;
      max-width: 1000px;
      margin: 25px auto;
      padding: 0 15px;
      display: none;
    }

    .roulette-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .roulette-title {
      font-size: 1.8em;
      margin: 0;
      color: #fff;
      background: linear-gradient(to right, #8a2387, #e94057, #f27121);
background-clip: text;
-webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .roulette-controls {
      display: flex;
      gap: 10px;
    }

    .roulette-control-btn {
      padding: 8px 15px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .roulette-control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }

.roulette-level {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  position: relative;
  min-height: 220px;
  display: flex;
  flex-direction: column;
}

.roulette-level-content {
  display: flex;
  gap: 20px;
  flex: 1;
}

.roulette-level-preview {
  width: 30%;
  flex-shrink: 0;
}

.roulette-level-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.roulette-level-stats {
  display: flex;
  gap: 20px;
  margin-top: 15px;
  flex-wrap: wrap;
}

.roulette-level-stat {
  background: rgba(0, 0, 0, 0.2);
  padding: 10px 15px;
  border-radius: 6px;
  flex: 1;
  min-width: 120px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

    .roulette-level-stat-label {
      font-size: 0.9em;
      color: #aaa;
      margin-bottom: 5px;
    }

    .roulette-level-stat-value {
      font-size: 1.1em;
      color: #fff;
    }

    .roulette-input-section {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      align-items: center;
    }

.roulette-input-section input {
  flex: 1;
  padding: 10px 15px;
  border-radius: 6px;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(0, 0, 0, 0.25);
  color: #fff;
  font-size: 1em;
  transition: all 0.3s ease;
}

.roulette-input-section input:focus {
  border-color: #ff4d4d;
  box-shadow: 0 0 0 2px rgba(255, 77, 77, 0.3);
  outline: none;
}

    .roulette-input-section button {
      padding: 10px 20px;
      background: linear-gradient(135deg, #1e88e5, #0d47a1);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .roulette-input-section button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
    }

    .time-machine-btn {
  position: absolute;
  right: 40px;
  background: transparent;
  color: rgba(255, 255, 255, 0.6);
  border: none;
  border-radius: 4px;
  padding: 5px;
  font-size: 1em;
  cursor: pointer;
  transition: all 0.3s ease;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.time-machine-btn:hover {
  color: #fff;
  background: rgba(255, 255, 255, 0.1);
}

.time-machine-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.time-machine-modal.active {
  display: flex;
  opacity: 1;
}

.time-machine-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  width: 90%;
  max-width: 400px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  padding: 25px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
}

.time-machine-header {
  margin-bottom: 20px;
  text-align: center;
}

.time-machine-title {
  font-size: 1.8em;
  margin: 0;
  color: #fff;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
}

.time-machine-body {
  padding: 0 10px 10px;
}

.time-machine-footer {
  display: flex;
  justify-content: flex-end;
  margin-top: 20px;
}

.time-machine-input {
  width: 100%;
  padding: 12px 15px;
  border-radius: 6px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  background: rgba(0, 0, 0, 0.25);
  color: #fff;
  font-size: 1em;
  margin-bottom: 15px;
}

.time-machine-input:focus {
  outline: none;
  border-color: #e94057;
  box-shadow: 0 0 0 2px rgba(233, 64, 87, 0.3);
}

    .skip-btn {
      padding: 10px 15px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 10px;
    }

    .skip-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }

    .roulette-history {
      margin-top: 30px;
    }

    .roulette-history-title {
      font-size: 1.3em;
      margin-bottom: 15px;
      color: #fff;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .roulette-history-item {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .roulette-history-level {
      flex: 1;
    }

    .roulette-history-percentage {
      font-weight: bold;
      color: #e94057;
      font-size: 1.1em;
    }

    .classic-range-group,
    .challenges-range-group {
        margin-top: 15px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
    }

    .classic-range-group label,
    .challenges-range-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #ddd;
    }

    .copyable-id {
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
}

.copyable-id:hover {
    color: #e94057;
}

.copyable-id:hover i {
    opacity: 1 !important;
}

.view-toggle-btn {
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 6px;
  padding: 12px 15px;
  font-size: 1em;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-left: 15px;
  display: flex;
  align-items: center;
}

.view-toggle-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.view-toggle-btn i {
  margin-right: 8px;
}

.compact-view .level {
  height: 50px; 
  padding: 5px;
  background-color: #1f2937;
}

.compact-view .level:hover {
    background-color: #374151 !important;
}

.compact-view .level-preview {
  width: 10%;
  margin-right: 8px;
}

.compact-view .level-info {
  width: 65%;
  padding-right: 0;
}

.compact-view .level-title {
  font-size: 1em;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-family: 'Montserrat', sans-serif;
  font-weight: 600;
}

.compact-view .level-author {
  font-size: 0.8em;
  margin: 2px 0 0 0;
}

.compact-view .level-verifier {
  display: none;
}

.compact-view .level-id {
  position: static;
  margin-left: auto;
  margin-right: 40px;
  display: inline-block;
  font-size: 0.8em; 
  padding: 2px 5px;
}

.compact-view .show-in-list {
  position: static;
  display: none !important;
  margin-right: 8px;
  font-size: 0.8em; 
  padding: 2px 5px;
}

  .compact-view.search-active .show-in-list {
    display: inline-block !important;
    margin-right: 8px;
    font-size: 0.8em;
    padding: 2px 5px;
  }

.compact-view .level-crown-container {
  top: 50%;
  right: 13px;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
}

.compact-view .level-crown {
  font-size: 0.8em;
}

.compact-view .level-new-container {
  position: static;
  margin-left: 70px;
  margin-right: 0px;
  width: 40px;
  height: 40px;
}

.search-mode-btn {
  position: absolute;
  right: 8px;
  background: transparent;
  color: rgba(255, 255, 255, 0.6);
  border: none;
  border-radius: 4px;
  padding: 5px;
  font-size: 1em;
  cursor: pointer;
  transition: all 0.3s ease;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.search-mode-btn:hover {
  color: #fff;
  background: rgba(255, 255, 255, 0.1);
}

.search-mode-btn i {
  margin-right: 8px;
}

.list-with-inputs {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 15px;
}

.list-input-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 15px;
}

.range-inputs {
    display: flex;
    gap: 10px;
}

.range-inputs input {
    width: 80px;
    padding: 8px 12px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    font-size: 0.9em;
    transition: all 0.3s ease;
}

.range-inputs input:focus {
    border-color: #e94057;
    box-shadow: 0 0 0 2px rgba(233, 64, 87, 0.3);
    outline: none;
}

.players-btn {
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 6px;
  padding: 10px;
  font-size: 1em;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-left: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
}

.players-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    @keyframes fadeOut {
      from { opacity: 1; transform: translateX(-50%) translateY(0); }
      to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
    }

  </style>

<!-- Подключение Montserrat с Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
  <!-- Компактная шапка -->
<div class="compact-header">
  <div class="header-left">
    <div class="header-title">DEMONLIST</div>
    
    <div class="dropdown">
      <button class="dropbtn" id="current-list-btn">
        <i class="fas fa-bars"></i>
        Lists
        <span class="dropdown-arrow"><i class="fas fa-angle-down"></i></span>
      </button>
      <div class="dropdown-content" id="dropdown-content">
        <a href="#" data-list="classic">Classic</a>
        <a href="#" data-list="challenges">Challenge</a>
        <a href="#" data-list="platformer">Platformer</a>
      </div>
    </div>
    
    <div class="search-container">
      <div class="search-input-wrapper">
        <input type="text" id="search-input" placeholder="Search...">
        <button class="search-mode-btn" id="search-mode-btn" title="Search mode">
          <i class="fas fa-font"></i>
        </button>
        <button class="time-machine-btn" id="time-machine-btn" title="Time Machine">
          <i class="fas fa-clock"></i>
        </button>
      </div>
    </div>
  </div>
  
<div class="header-right">
  <button class="players-btn" id="players-btn" title="Top Players">
    <i class="fas fa-trophy"></i>
  </button>
  
  <button class="view-toggle-btn" id="view-toggle-btn">
    <i class="fas fa-th-large"></i> Compact View
  </button>
  
  <button class="roulette-btn" id="roulette-btn">
    <i class="fas fa-dice"></i> Roulette
  </button>
</div>
</div>

  <!-- Модальное окно Demon Roulette -->
<div class="modal" id="roulette-modal">
    <div class="modal-content roulette-modal-content">
        <button class="modal-close" id="modal-close" style="
    background: rgba(255,255,255,0.1);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
">
    <i class="fas fa-times" style="font-size: 1.2em;"></i>
</button>
        <div class="modal-header roulette-modal-header">
            <h2 class="modal-title roulette-modal-title">Demon Roulette</h2>
        </div>
        
<div class="roulette-settings-container">
    <!-- Секция выбора списков -->
    <div class="roulette-setting-group">
        <div class="roulette-setting-label">
            <i class="fas fa-layer-group" style="margin-right: 8px;"></i>
            List Selection
        </div>
        
<div class="list-with-inputs">
    <div class="list-input-row">
        <label class="roulette-checkbox-label">
            <input type="checkbox" id="roulette-classic" checked>
            <span class="roulette-checkbox-custom"></span>
            <span>Classic List</span>
        </label>
        <div class="range-inputs">
            <input type="number" id="roulette-classic-min" placeholder="Min" min="1" value="1" class="no-spinners">
            <input type="number" id="roulette-classic-max" placeholder="Max" min="1" value="1000" class="no-spinners">
        </div>
    </div>
    
    <div class="list-input-row">
        <label class="roulette-checkbox-label">
            <input type="checkbox" id="roulette-challenges">
            <span class="roulette-checkbox-custom"></span>
            <span>Challenge List</span>
        </label>
        <div class="range-inputs">
            <input type="number" id="roulette-challenges-min" placeholder="Min" min="1" value="1" class="no-spinners">
            <input type="number" id="roulette-challenges-max" placeholder="Max" min="1" value="1000" class="no-spinners">
        </div>
    </div>
</div>
    </div>
    
    <!-- Объединенная секция настроек -->
    <div class="roulette-setting-group">
        <div class="roulette-setting-label">
            <i class="fas fa-cog" style="margin-right: 8px;"></i>
            Roulette Settings
        </div>
<div class="roulette-settings-options" style="position: relative;">
    <label class="roulette-checkbox-label">
        <input type="checkbox" id="enable-skips" checked>
        <span class="roulette-checkbox-custom"></span>
        <span>Skips Allowed</span>
    </label>
    <input type="number" id="skip-count" min="0" max="100" value="3" class="no-spinners" style="position: absolute; right: 0; width: 180px;">
    
    <label class="roulette-checkbox-label">
        <input type="checkbox" id="skip-adds-percent" checked>
        <span class="roulette-checkbox-custom"></span>
        <span>Skip Adds +1%</span>
    </label>
    <label class="roulette-checkbox-label">
        <input type="checkbox" id="allow-repeats">
        <span class="roulette-checkbox-custom"></span>
        <span>Allow Level Repeats</span>
    </label>
    <label class="roulette-checkbox-label">
        <input type="checkbox" id="max-plus-one">
        <span class="roulette-checkbox-custom"></span>
        <span>Max +1%</span>
    </label>
</div>
    </div>
    
    <!-- Новый раздел Filter Levels -->
    <div class="roulette-setting-group">
        <div class="roulette-setting-label">
            <i class="fas fa-filter" style="margin-right: 8px;"></i>
            Filter Levels
        </div>
        <div class="roulette-settings-options">
            <label class="roulette-checkbox-label">
                <input type="checkbox" id="filter-unrated">
                <span class="roulette-checkbox-custom"></span>
                <span>Filter Unrated Levels</span>
            </label>
            <label class="roulette-checkbox-label">
                <input type="checkbox" id="filter-2player">
                <span class="roulette-checkbox-custom"></span>
                <span>Filter 2-Player Levels</span>
            </label>
        </div>
    </div>
</div>
        
        <button class="roulette-spin-btn" id="spin-btn">
            Spin The Roulette
        </button>
    </div>
</div>

  <!-- Секция Demon Roulette -->
  <div class="roulette-section" id="roulette-section">
    <div class="roulette-header">
      <h2 class="roulette-title">Demon Roulette</h2>
      <div class="roulette-controls">
        <button class="roulette-control-btn" id="roulette-end-btn">
          <i class="fas fa-stop"></i> End Roulette
        </button>
        <button class="roulette-control-btn" id="roulette-export-btn">
          <i class="fas fa-file-export"></i> Export
        </button>
        <button class="roulette-control-btn" id="roulette-import-btn">
          <i class="fas fa-file-import"></i> Import
        </button>
      </div>
    </div>
    
    <div id="roulette-levels-container"></div>
    
    <div class="roulette-history" id="roulette-history">
      <h3 class="roulette-history-title">
        <i class="fas fa-history"></i> History
      </h3>
      <div id="history-container"></div>
    </div>
  </div>

  <!-- Контейнеры с уровнями -->
  <div class="level-container" id="classic-list"></div>
  <div class="level-container" id="challenges-list" style="display: none;"></div>
  <div class="level-container" id="platformer-list" style="display: none;"></div>

  <!-- Кнопка "Наверх" -->
<button class="scroll-to-top" aria-label="Scroll to top">
  <i class="fas fa-arrow-up"></i>
</button>

<!-- Кнопка Filters -->
<button class="filters-btn" aria-label="Filters" id="filters-btn">
  <i class="fas fa-filter"></i>
</button>

  <!-- Скрытый input для импорта -->
<input type="file" id="import-file" accept=".txt,.json" style="display: none;">

<script src="levelData.js"></script>

  <script>

    // Функции для работы с localStorage
function saveToLocalStorage(key, value) {
    try {
        localStorage.setItem(key, JSON.stringify(value));
    } catch (e) {
        console.error('Error saving to localStorage:', e);
    }
}

function loadFromLocalStorage(key) {
    try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : null;
    } catch (e) {
        console.error('Error loading from localStorage:', e);
        return null;
    }
}

function saveAllSettings() {
    saveToLocalStorage('compactView', document.getElementById('classic-list').classList.contains('compact-view'));
    saveToLocalStorage('searchMode', searchMode);
    saveToLocalStorage('filterUnratedLevels', document.getElementById('filter-unrated-levels').checked);
    saveToLocalStorage('filter2PlayerLevels', document.getElementById('filter-2player-levels').checked);
    saveToLocalStorage('filterInvisibleLevels', document.getElementById('filter-invisible-levels').checked);
    saveToLocalStorage('filterChallengesLevels', document.getElementById('filter-challenges-levels').checked);
    
    // Сохраняем только настройки рулетки, но не её состояние
    const rouletteSettings = {
        classicList: document.getElementById('roulette-classic').checked,
        challengesList: document.getElementById('roulette-challenges').checked,
        classicMin: parseInt(document.getElementById('roulette-classic-min').value) || 1,
        classicMax: parseInt(document.getElementById('roulette-classic-max').value) || 1000,
        challengesMin: parseInt(document.getElementById('roulette-challenges-min').value) || 1,
        challengesMax: parseInt(document.getElementById('roulette-challenges-max').value) || 1000,
        allowRepeats: document.getElementById('allow-repeats').checked,
        skipCount: parseInt(document.getElementById('skip-count').value) || 0,
        skipAddsPercent: document.getElementById('skip-adds-percent').checked,
        filterUnrated: document.getElementById('filter-unrated').checked,
        filter2Player: document.getElementById('filter-2player').checked,
        maxPlusOne: document.getElementById('max-plus-one').checked
    };
    
    saveToLocalStorage('rouletteSettings', rouletteSettings);
}

function loadAllSettings() {
    // Загрузка compact view
    const compactView = loadFromLocalStorage('compactView');
    if (compactView) {
        document.getElementById('classic-list').classList.toggle('compact-view', compactView);
        document.getElementById('challenges-list').classList.toggle('compact-view', compactView);
        document.getElementById('platformer-list').classList.toggle('compact-view', compactView);
        
        if (compactView) {
            document.getElementById('view-toggle-btn').innerHTML = '<i class="fas fa-th-list"></i> Normal View';
        }
    }
    
    // Загрузка search mode
    const savedSearchMode = loadFromLocalStorage('searchMode');
    if (savedSearchMode) {
        searchMode = savedSearchMode;
        document.getElementById('search-mode-btn').innerHTML = searchMode === 'contains' 
            ? '<i class="fas fa-font"></i>' 
            : '<i class="fas fa-text-width"></i>';
        document.getElementById('search-mode-btn').title = searchMode === 'contains' 
            ? 'Contains mode' 
            : 'Starts with mode';
    }

    // Загрузка фильтров
    const filterUnratedLevels = loadFromLocalStorage('filterUnratedLevels');
    const filter2PlayerLevels = loadFromLocalStorage('filter2PlayerLevels');
    const filterInvisibleLevels = loadFromLocalStorage('filterInvisibleLevels');
    const filterChallengesLevels = loadFromLocalStorage('filterChallengesLevels');
    
    if (filterUnratedLevels !== null) {
        document.getElementById('filter-unrated-levels').checked = filterUnratedLevels;
    }
    if (filter2PlayerLevels !== null) {
        document.getElementById('filter-2player-levels').checked = filter2PlayerLevels;
    }
    if (filterInvisibleLevels !== null) {
        document.getElementById('filter-invisible-levels').checked = filterInvisibleLevels;
    }
    if (filterChallengesLevels !== null) {
        document.getElementById('filter-challenges-levels').checked = filterChallengesLevels;
    }
    
    // Загрузка настроек рулетки (но не состояния)
    const savedRouletteSettings = loadFromLocalStorage('rouletteSettings');
    if (savedRouletteSettings) {
        document.getElementById('roulette-classic').checked = savedRouletteSettings.classicList;
        document.getElementById('roulette-challenges').checked = savedRouletteSettings.challengesList;
        document.getElementById('roulette-classic-min').value = savedRouletteSettings.classicMin;
        document.getElementById('roulette-classic-max').value = savedRouletteSettings.classicMax;
        document.getElementById('roulette-challenges-min').value = savedRouletteSettings.challengesMin;
        document.getElementById('roulette-challenges-max').value = savedRouletteSettings.challengesMax;
        document.getElementById('allow-repeats').checked = savedRouletteSettings.allowRepeats;
        document.getElementById('skip-count').value = savedRouletteSettings.skipCount;
        document.getElementById('skip-adds-percent').checked = savedRouletteSettings.skipAddsPercent;
        document.getElementById('filter-unrated').checked = savedRouletteSettings.filterUnrated;
        document.getElementById('filter-2player').checked = savedRouletteSettings.filter2Player;
        document.getElementById('max-plus-one').checked = savedRouletteSettings.maxPlusOne;
    }
    
    // Всегда сбрасываем состояние рулетки при загрузке
    rouletteState = {
        active: false,
        allowRepeats: false,
        currentLevel: null,
        history: [],
        usedLevels: new Set(),
        totalSkips: 0,
        remainingSkips: 0
    };
}

// Функция для проверки дубликатов ID
function checkForDuplicateIds() {
    const allIds = {};
    const duplicates = {};
    
    // Проверяем все списки уровней
    for (const listType in levelData) {
        levelData[listType].forEach(level => {
            if (!allIds[level.id]) {
                allIds[level.id] = [];
            }
            allIds[level.id].push({
                title: level.title,
                listType: listType
            });
        });
    }
    
    // Находим дубликаты
    for (const id in allIds) {
        if (allIds[id].length > 1) {
            duplicates[id] = allIds[id];
        }
    }
    
    // Если есть дубликаты - показываем сообщение
    if (Object.keys(duplicates).length > 0) {
        let message = 'Found levels with duplicate IDs:\n\n';
        
        for (const id in duplicates) {
            message += `ID: ${id}\n`;
            duplicates[id].forEach(level => {
                message += `- ${level.title} (${level.listType} list)\n`;
            });
            message += '\n';
        }
        
        showCustomAlert(message, false);
        console.warn('Duplicate level IDs found:', duplicates);
    }
}

// Функция для преобразования строки длительности в секунды
function parseDurationToSeconds(durationStr) {
    if (!durationStr) return 0;
    
    // Регулярное выражение для поиска компонентов времени
    const regex = /(\d+d)?\s*(\d+h)?\s*(\d+m)?\s*(\d+s)?/;
    const matches = durationStr.match(regex);
    
    let seconds = 0;
    
    if (matches) {
        if (matches[1]) seconds += parseInt(matches[1]) * 86400; // дни
        if (matches[2]) seconds += parseInt(matches[2]) * 3600;  // часы
        if (matches[3]) seconds += parseInt(matches[3]) * 60;    // минуты
        if (matches[4]) seconds += parseInt(matches[4]);         // секунды
    }
    
    return seconds;
}

let searchMode = 'contains'; // 'contains' или 'startsWith'
let lastSubmitTime = 0; // Для кулдауна

// Функция для определения, был ли уровень на первом месте при выходе
function wasFirstPlaceOnRelease(level, listType) {
    const releaseDate = new Date(level.releaseDate);
    if (isNaN(releaseDate.getTime())) return false;
    
    // Находим индекс текущего уровня в списке
    const levelIndex = levelData[listType].findIndex(l => l.id === level.id);
    if (levelIndex === -1) return false;
    
    // Находим все уровни, выпущенные до или в тот же день, кроме исключений
    const levelsBefore = levelData[listType].filter(l => {
        if (!l.releaseDate) return false;
        
        // Игнорируем Amethyst только для Thinking Space II
        if (level.title === "Thinking Space II" && l.title === "Amethyst") {
            return false;
        }
        
        // Игнорируем Silent clubstep для Acheron, Acheron buffed и Avernus
        const isAcheronGroup = ["Acheron", "Acheron buffed"].includes(level.title);
        if (isAcheronGroup && l.title === "Silent clubstep") {
            return false;
        }
        
        const lDate = new Date(l.releaseDate);
        return lDate <= releaseDate;
    });
    
    // Если нет других уровней или наш уровень самый старый
    if (levelsBefore.length === 0) return false;
    
    // Сортируем по позиции в списке (чем выше позиция - тем сложнее уровень)
    const sortedByPosition = [...levelsBefore].sort((a, b) => {
        const posA = levelData[listType].indexOf(a) + 1;
        const posB = levelData[listType].indexOf(b) + 1;
        return posA - posB;
    });
    
    // Самый сложный уровень среди выпущенных до или в тот же день
    const hardestLevel = sortedByPosition[0];
    
    // Проверяем, является ли наш уровень самым сложным среди выпущенных в этот день
    return hardestLevel.id === level.id;
}

// Функция для проверки, является ли уровень новым (вышел в последние 30 дней)
function isLevelNew(releaseDate) {
    if (!releaseDate) return false;
    
    const release = new Date(releaseDate);
    if (isNaN(release.getTime())) return false;
    
    const currentDate = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(currentDate.getDate() - 30);
    
    return release >= thirtyDaysAgo && release <= currentDate;
}

    // Функция для генерации HTML уровня
function generateLevelHTML(level, position, listType) {
  let isFormerFirstPlace = wasFirstPlaceOnRelease(level, listType);
  
  // Проверяем, является ли уровень новым (вышел в последние 30 дней)
  const isNewLevel = isLevelNew(level.releaseDate);
  
  // Определяем цвет названия в зависимости от условий
  let titleColorClass = '';
  if (!level.lenght && !level.previewImg) {
      // Нет ни lenght, ни previewImg - оставляем стандартный цвет
  } else if (!level.lenght) {
      // Нет lenght - оранжевый
      titleColorClass = 'no-length-title';
  } else if (level.previewImg) {
      // Есть previewImg - желтый
      titleColorClass = 'has-preview-title';
  }
  
  // Если нет lenght И есть previewImg - красный (переопределяем предыдущие условия)
  if (!level.lenght && level.previewImg) {
      titleColorClass = 'no-length-has-preview-title';
  }
  
  // Определяем URL превью: если явно указан - используем его, иначе генерируем из ID
  const previewUrl = level.previewImg 
    ? level.previewImg 
    : `images/${level.id}.png`;
  
  return `
    <div class="level ${!level.lenght ? 'no-length-level' : ''}">
      <div class="level-preview">
        <a href="${level.videoUrl}" target="_blank">
          <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiA5Ii8+" 
               data-src="${previewUrl}" 
               alt="Level Preview" 
               loading="lazy" 
               width="400" 
               height="225">
        </a>
      </div>
      <div class="level-info">
        <h2 class="level-title ${titleColorClass}">#${position} - ${level.title}</h2>
        <p class="level-author">Published by ${level.author}</p>
        <p class="level-verifier">Verified by ${level.verifier}</p>
      </div>
      ${isNewLevel ? '<div class="level-new-container" title="New Level (Verified in last 30 days)"><img src="images/new_label.png" alt="NEW"></div>' : ''}
      ${isFormerFirstPlace ? '<div class="level-crown-container" title="Former Hardest Level"><img src="images/Crown.png" alt="👑" style="width: 100%; height: 100%; object-fit: contain;"></div>' : ''}
      <div class="show-in-list" onclick="scrollToLevel(this)">Show in List</div>
      <div class="level-id" onclick="copyToClipboard(this, '${level.id}')">${level.id}</div>
    </div>
  `;
}

// Функция для отрисовки списка уровней с учетом фильтров
function renderLevels(listType) {
    const container = document.getElementById(`${listType}-list`);
    if (!container) return;
    
    let html = '';
    const filterUnrated = document.getElementById('filter-unrated-levels').checked;
    let position = 1;
    
    levelData[listType].forEach((level) => {
        // Применяем фильтр Unrated
        if (filterUnrated && level.tags && level.tags.includes("Unrated")) {
            return; // Пропускаем уровень
        }
        
        html += generateLevelHTML(level, position, listType);
        position++;
    });
    
    container.innerHTML = html;
    setupLazyLoading();
    
    // Проверяем дубликаты после рендеринга
    checkForDuplicateIds();
}

    // Demon Roulette State
    let rouletteState = {
        active: false,
        allowRepeats: false,
        currentLevel: null,
        history: [],
        usedLevels: new Set(),
        totalSkips: 0,
        remainingSkips: 0
    };

    function formatDuration(seconds) {
    seconds = parseInt(seconds);
    if (isNaN(seconds)) return "N/A";
    
    const days = Math.floor(seconds / 86400);
    seconds %= 86400;
    const hours = Math.floor(seconds / 3600);
    seconds %= 3600;
    const minutes = Math.floor(seconds / 60);
    seconds %= 60;
    
    let parts = [];
    if (days > 0) parts.push(`${days}d`);
    if (hours > 0) parts.push(`${hours}h`);
    if (minutes > 0) parts.push(`${minutes}m`);
    if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);
    
    return parts.join(' ');
}

    // Функция для генерации HTML уровня в рулетке
function generateRouletteLevelHTML(level, position, listType, minPercentage = 1) {
    const maxPlusOne = document.getElementById('max-plus-one').checked;
    const listName = listType === 'classic' ? 'Classic List' : 'Challenge List';
    const isFormerFirstPlace = wasFirstPlaceOnRelease(level, listType);
    
    // Определяем URL превью: если явно указан - используем его, иначе генерируем из ID
    const previewUrl = level.previewImg 
        ? level.previewImg 
        : `images/${level.id}.png`;
    
    return `
    <div class="roulette-level">
        ${isFormerFirstPlace ? '<div class="level-crown-container" title="Former Hardest Level"><img src="images/Crown.png" alt="👑" style="width: 100%; height: 100%; object-fit: contain;"></div>' : ''}
        <div class="roulette-level-header">
            <h3 class="roulette-level-title">#${position} - ${level.title}</h3>
        </div>
        <div class="roulette-level-content">
            <div class="roulette-level-preview">
                <a href="${level.videoUrl}" target="_blank">
                    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiA5Ii8+" 
                         data-src="${previewUrl}" 
                         alt="${level.title} preview" 
                         loading="lazy" 
                         width="300"
                         height="169">
                </a>
            </div>
            <div class="roulette-level-info">
                <div class="roulette-level-stats">
                    <div class="roulette-level-stat">
                        <div class="roulette-level-stat-label">Publisher</div>
                        <div class="roulette-level-stat-value">${level.author}</div>
                    </div>
<div class="roulette-level-stat">
    <div class="roulette-level-stat-label">Length</div>
    <div class="roulette-level-stat-value">${level.lenght ? formatDuration(level.lenght) : 'N/A'}</div>
</div>
                    <div class="roulette-level-stat">
                        <div class="roulette-level-stat-label">ID</div>
                        <div class="roulette-level-stat-value copyable-id" onclick="copyToClipboard(this, '${level.id}')" title="Click to copy">
                            ${level.id}
                            <i class="fas fa-copy" style="margin-left: 5px; font-size: 0.8em; opacity: 0.7;"></i>
                        </div>
                    </div>
                </div>
                
                <div class="roulette-input-section">
                    ${maxPlusOne ? `
                        <input type="number" id="percentage-input" value="${minPercentage}" min="${minPercentage}" max="100" readonly class="no-spinners">
                        <button id="submit-percentage">Submit</button>
                    ` : `
                        <input type="number" id="percentage-input" placeholder="Enter your percentage (${minPercentage}-100)" min="${minPercentage}" max="100">
                        <button id="submit-percentage">Submit</button>
                    `}
                    ${rouletteState.remainingSkips > 0 ? `<button id="skip-level" class="skip-btn">Skip (${rouletteState.remainingSkips} left)</button>` : ''}
                </div>
            </div>
        </div>
    </div>
    `;
}

// Функция для генерации HTML истории
function generateHistoryHTML() {
    if (rouletteState.history.length === 0) return '<p>No History Yet</p>';
    
    // Получаем текущие настройки рулетки или используем значения по умолчанию
    let classicChecked = false;
    let challengesChecked = false;
    let platformerChecked = false;
    
    try {
        const classicCheckbox = document.getElementById('roulette-classic');
        const challengesCheckbox = document.getElementById('roulette-challenges');
        const platformerCheckbox = document.getElementById('roulette-platformer');
        
        classicChecked = classicCheckbox ? classicCheckbox.checked : false;
        challengesChecked = challengesCheckbox ? challengesCheckbox.checked : false;
        platformerChecked = platformerCheckbox ? platformerCheckbox.checked : false;
    } catch (e) {
        console.error('Error getting checkbox states:', e);
    }
    
    // Показывать тип только если выбрано больше одного списка
    const showListType = [classicChecked, challengesChecked, platformerChecked].filter(Boolean).length > 1;
    
    let html = '';
    // Перебираем историю в обратном порядке (новые сверху)
    for (let i = rouletteState.history.length - 1; i >= 0; i--) {
        const item = rouletteState.history[i];
        
        // Определяем тип списка
        let listType = '';
        if (showListType) {
            if (levelData.classic.some(l => l.id === item.level.id)) {
                listType = ' (Classic)';
            } else if (levelData.challenges.some(l => l.id === item.level.id)) {
                listType = ' (Challenge)';
            } else if (levelData.platformer.some(l => l.id === item.level.id)) {
                listType = ' (Platformer)';
            }
        }
        
        const levelInfo = `#${item.position}${listType} - ${item.level.title}`;
        
        html += `
            <div class="roulette-history-item">
                <div class="roulette-history-level">
                    ${levelInfo}
                </div>
                <div class="roulette-history-percentage">
                    ${item.percentage === 'Skipped' ? '<span style="color:#aaa">Skipped</span>' : item.percentage + '%'}
                </div>
            </div>
        `;
    }
    return html;
}

    // Функция для получения случайного уровня
    function getRandomLevel() {
        const { allowRepeats } = rouletteState;
        
        // Собираем все уровни из выбранных списков с их диапазонами
        let allLevels = [];
        let positionMap = [];
        
        if (document.getElementById('roulette-classic').checked) {
            const minPos = parseInt(document.getElementById('roulette-classic-min').value) || 1;
            const maxPos = parseInt(document.getElementById('roulette-classic-max').value) || 1000;
            const levels = levelData['classic'];
            levels.forEach((level, index) => {
                const position = index + 1;
                if (position >= minPos && position <= maxPos) {
                    allLevels.push(level);
                    positionMap.push({ listType: 'classic', position });
                }
            });
        }
        
        if (document.getElementById('roulette-challenges').checked) {
            const minPos = parseInt(document.getElementById('roulette-challenges-min').value) || 1;
            const maxPos = parseInt(document.getElementById('roulette-challenges-max').value) || 1000;
            const levels = levelData['challenges'];
            levels.forEach((level, index) => {
                const position = index + 1;
                if (position >= minPos && position <= maxPos) {
                    allLevels.push(level);
                    positionMap.push({ listType: 'challenges', position });
                }
            });
        }
        
        if (allLevels.length === 0) return null;
        
        // Фильтруем уровни, которые еще не использовались и соответствуют фильтрам
        const availableLevels = allLevels.filter((level, index) => {
            const { listType, position } = positionMap[index];
            const levelKey = `${listType}-${position}`;
            
            // Проверка на повторное использование
            if (!allowRepeats && rouletteState.usedLevels.has(levelKey)) {
                return false;
            }
            
            // Проверка фильтров уровней
            const filterUnrated = document.getElementById('filter-unrated').checked;
            const filter2Player = document.getElementById('filter-2player').checked;
            
            if (filterUnrated && level.tags && level.tags.includes("Unrated")) {
                return false;
            }
            
            if (filter2Player && level.tags && level.tags.includes("2Player")) {
                return false;
            }
            
            return true;
        });
        
        if (availableLevels.length === 0) return null;
        
        // Выбираем случайный уровень
        const randomIndex = Math.floor(Math.random() * availableLevels.length);
        const level = availableLevels[randomIndex];
        
        // Находим соответствующую позицию и тип списка
        const originalIndex = allLevels.indexOf(level);
        const { listType, position } = positionMap[originalIndex];
        const levelKey = `${listType}-${position}`;
        
        // Добавляем в использованные
        rouletteState.usedLevels.add(levelKey);
        
        return { level, position, listType };
    }

    // Функция для запуска рулетки
function startRoulette() {
    console.log('Starting roulette...'); // Добавлено для отладки
    
    // Очищаем историю при старте
    rouletteState.history = [];
    document.getElementById('history-container').innerHTML = '<p>No History Yet</p>';
    
    const allowRepeats = document.getElementById('allow-repeats').checked;
    const skipEnabled = document.getElementById('enable-skips').checked;
    const skipCount = skipEnabled ? parseInt(document.getElementById('skip-count').value) || 3 : 0;
    const skipAddsPercent = document.getElementById('skip-adds-percent').checked;
    
    // Получаем выбранные типы списков
    const listTypes = [];
    if (document.getElementById('roulette-classic').checked) {
        listTypes.push('classic');
    }
    if (document.getElementById('roulette-challenges').checked) {
        listTypes.push('challenges');
    }
    
    // Обновляем состояние рулетки
    rouletteState = {
        active: true,
        allowRepeats,
        currentLevel: null,
        history: [],
        usedLevels: new Set(),
        totalSkips: skipCount,
        remainingSkips: skipCount,
        skipAddsPercent
    };
    
    console.log('Roulette state initialized:', rouletteState); // Добавлено для отладки
    
    // Прокручиваем страницу вверх
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
    
    // Показываем секцию рулетки
    document.getElementById('roulette-section').style.display = 'block';
    console.log('Roulette section shown'); // Добавлено для отладки
    
    // Генерируем первый уровень
    generateNextLevel();
    console.log('First level generated'); // Добавлено для отладки

    // Сохраняем состояние
    saveAllSettings();
}

    // Функция для генерации следующего уровня
function generateNextLevel() {
    console.log('Generating next level...');
    
    const levelData = getRandomLevel();
    
    if (!levelData) {
        console.log('No levels available');
        showCustomAlert('No more levels available in the selected range!');
        endRoulette();
        return;
    }
    
    rouletteState.currentLevel = levelData;
    console.log('Selected level:', levelData.level.title);
    
    let minPercentage = calculateMinPercentage();
    console.log('Min percentage:', minPercentage);
    
    const container = document.getElementById('roulette-levels-container');
    container.innerHTML = generateRouletteLevelHTML(
        levelData.level, 
        levelData.position,
        levelData.listType,
        minPercentage
    );
    console.log('Level HTML generated');
    
// Добавляем небольшую задержку перед фокусировкой, чтобы DOM успел обновиться
const focusInput = () => {
    const percentageInput = document.getElementById('percentage-input');
    if (percentageInput && document.body.contains(percentageInput)) {
        try {
            percentageInput.focus();
            const len = percentageInput.value.length;
            percentageInput.setSelectionRange(len, len);
        } catch (e) {
            console.error('Error focusing input:', e);
        }
    } else {
        requestAnimationFrame(focusInput);
    }
};

requestAnimationFrame(focusInput);

    setupLazyLoading();
    console.log('Next level setup complete');
}

// Новая функция для расчета минимального процента
function calculateMinPercentage() {
    let minPercentage = 1;
    if (rouletteState.history.length > 0) {
        for (let i = rouletteState.history.length - 1; i >= 0; i--) {
            if (rouletteState.history[i].percentage !== 'Skipped') {
                minPercentage = parseInt(rouletteState.history[i].percentage) + 1;
                break;
            }
        }
        
        if (document.getElementById('skip-adds-percent').checked) {
            const lastNonSkippedIndex = rouletteState.history.findIndex(item => 
                item.percentage !== 'Skipped' && 
                parseInt(item.percentage) === minPercentage - 1
            );
            
            if (lastNonSkippedIndex >= 0) {
                const skipsAfter = rouletteState.history.slice(lastNonSkippedIndex + 1)
                    .filter(item => item.percentage === 'Skipped').length;
                
                minPercentage += skipsAfter;
            }
        }
        
        if (rouletteState.lastPercentage) {
            minPercentage = rouletteState.lastPercentage;
            delete rouletteState.lastPercentage;
        }
    }
    return minPercentage;
}

    // Функция для пропуска уровня
function skipLevel() {
    if (rouletteState.remainingSkips <= 0) return;
    
    rouletteState.remainingSkips--;

    // Сохраняем состояние рулетки
saveAllSettings();
    
    // Добавляем в историю
    rouletteState.history.push({
        level: rouletteState.currentLevel.level,
        position: rouletteState.currentLevel.position,
        percentage: 'Skipped'
    });
    
// Если включена опция "Skip adds percent", увеличиваем минимальный процент
const skipAddsPercent = document.getElementById('skip-adds-percent').checked;
if (skipAddsPercent) {
    // Находим последний введенный процент (не пропущенный)
    let lastPercentage = 1;
    for (let i = rouletteState.history.length - 1; i >= 0; i--) {
        if (rouletteState.history[i].percentage !== 'Skipped') {
            lastPercentage = parseInt(rouletteState.history[i].percentage);
            break;
        }
    }
    
    // Увеличиваем минимальный процент на количество пропусков +1
    const skipCount = rouletteState.history.filter(item => 
        item.percentage === 'Skipped' && 
        rouletteState.history.indexOf(item) > rouletteState.history.findIndex(i => i.percentage === lastPercentage)
    ).length;
    
    rouletteState.lastPercentage = lastPercentage + skipCount + 1;
}
    
    // Обновляем историю
    document.getElementById('history-container').innerHTML = generateHistoryHTML();
    
    // Генерируем следующий уровень
    generateNextLevel();
}

    // Функция для отправки процента
function submitPercentage() {
    const now = Date.now();
    
    // Кулдаун 200ms для всех случаев
    if (now - lastSubmitTime < 200) {
        return;
    }
    lastSubmitTime = now;

    const input = document.getElementById('percentage-input');
    let percentage;
    
    if (document.getElementById('max-plus-one').checked) {
        percentage = parseInt(input.value);
    } else {
        percentage = parseInt(input.value);
        const minPercentage = parseInt(input.min) || 1;
        
        // Проверка на корректность ввода
        if (isNaN(percentage)) {
            showCustomAlert('Please enter a valid percentage!');
            return;
        }
        
        if (percentage < minPercentage || percentage > 100) {
            showCustomAlert(`Percentage must be between ${minPercentage} and 100!`);
            return;
        }
    }
    
    // Проверка на 100%
    if (percentage === 100) {
        showCustomAlert('Congratulations! You completed the roulette with 100%!', true);
        endRoulette();
        return;
    }
    
    // Добавляем в историю
    rouletteState.history.push({
        level: rouletteState.currentLevel.level,
        position: rouletteState.currentLevel.position,
        percentage: percentage
    });
    
    // Обновляем историю
    document.getElementById('history-container').innerHTML = generateHistoryHTML();
    
    // Генерируем следующий уровень
    generateNextLevel();

    // Сохраняем состояние рулетки
saveAllSettings();
}

    // Функция для завершения рулетки
function endRoulette() {
    rouletteState.active = false;
    document.getElementById('roulette-section').style.display = 'none';
    showCustomAlert('Roulette ended', true);
}

    // Функция для очистки истории рулетки
    function clearRouletteHistory() {
      rouletteState.history = [];
      document.getElementById('history-container').innerHTML = generateHistoryHTML();
    }

    // Функция для экспорта истории
function exportRouletteData() {
    const exportData = {
        settings: {
            classicList: document.getElementById('roulette-classic').checked,
            challengesList: document.getElementById('roulette-challenges').checked,
            maxPlusOne: document.getElementById('max-plus-one').checked,
            platformerList: document.getElementById('roulette-platformer').checked,
            classicMin: parseInt(document.getElementById('roulette-classic-min').value) || 1,
            classicMax: parseInt(document.getElementById('roulette-classic-max').value) || 1000,
            challengesMin: parseInt(document.getElementById('roulette-challenges-min').value) || 1,
            challengesMax: parseInt(document.getElementById('roulette-challenges-max').value) || 1000,
            platformerMin: parseInt(document.getElementById('roulette-platformer-min').value) || 1,
            platformerMax: parseInt(document.getElementById('roulette-platformer-max').value) || 1000,
            allowRepeats: document.getElementById('allow-repeats').checked,
            skipCount: parseInt(document.getElementById('skip-count').value) || 0,
            skipAddsPercent: document.getElementById('skip-adds-percent').checked,
            filterUnrated: document.getElementById('filter-unrated').checked,
            filter2Player: document.getElementById('filter-2player').checked
        },
        history: rouletteState.history.map(item => ({
            title: item.level.title,
            percentage: item.percentage,
            position: item.position,
            listType: levelData.classic.some(l => l.id === item.level.id) ? 'classic' : 
                     levelData.challenges.some(l => l.id === item.level.id) ? 'challenges' : 'platformer'
        })),
        currentLevel: rouletteState.currentLevel ? {
            title: rouletteState.currentLevel.level.title,
            position: rouletteState.currentLevel.position,
            listType: rouletteState.currentLevel.listType,
            percentage: document.getElementById('percentage-input')?.value || 0
        } : null,
        remainingSkips: rouletteState.remainingSkips
    };

    // Создаем имя файла с текущей датой и временем
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10);
    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '-');
    const filename = `demonlist_roulette_${dateStr}_${timeStr}.json`;

    // Создаем Blob с данными
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });

    // Создаем ссылку для скачивания
    const url = URL.createObjectURL(dataBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    // Добавляем ссылку в документ и эмулируем клик
    document.body.appendChild(a);
    a.click();
    
    // Удаляем ссылку и освобождаем память
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showCustomAlert(`File "${filename}" has been saved`, true);
    }, 100);
}

function calculateMinPercentage() {
    if (rouletteState.history.length === 0) return 1;
    
    let minPercentage = 1;
    // Находим последний введенный процент (не пропущенный)
    for (let i = rouletteState.history.length - 1; i >= 0; i--) {
        if (rouletteState.history[i].percentage !== 'Skipped') {
            minPercentage = parseInt(rouletteState.history[i].percentage) + 1;
            break;
        }
    }
    
    // Если включена опция "Skip adds percent", добавляем +1% за каждый пропуск после последнего введенного процента
    const skipAddsPercent = document.getElementById('skip-adds-percent').checked;
    if (skipAddsPercent) {
        const lastNonSkippedIndex = rouletteState.history.findIndex(item => 
            item.percentage !== 'Skipped' && 
            parseInt(item.percentage) === minPercentage - 1
        );
        
        if (lastNonSkippedIndex >= 0) {
            const skipsAfter = rouletteState.history.slice(lastNonSkippedIndex + 1)
                .filter(item => item.percentage === 'Skipped').length;
            
            minPercentage += skipsAfter;
        }
    }
    
    return minPercentage;
}

    // Функция для импорта истории
function importRouletteData(file) {
    // Проверяем расширение файла
    const fileName = file.name.toLowerCase();
    if (!fileName.endsWith('.txt') && !fileName.endsWith('.json')) {
        showCustomAlert('Please select a .txt or .json file');
        return;
    }

    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            let data;
            // Пытаемся парсить как JSON независимо от расширения
            try {
                data = JSON.parse(e.target.result);
            } catch (jsonError) {
                // Если не получилось как JSON, пробуем как старый TXT формат
                if (fileName.endsWith('.txt')) {
                    try {
                        // Старый формат TXT - это на самом деле тоже JSON
                        data = JSON.parse(e.target.result);
                    } catch (txtError) {
                        throw new Error("File is not in valid JSON format");
                    }
                } else {
                    throw jsonError;
                }
            }

            // Проверяем структуру данных
            if (!data.settings || !data.history) {
                throw new Error("Invalid file format - missing required data");
            }
            
            // Загружаем настройки (остальной код остается без изменений)
            document.getElementById('roulette-classic').checked = data.settings.classicList;
            document.getElementById('roulette-challenges').checked = data.settings.challengesList;
            document.getElementById('roulette-platformer').checked = data.settings.platformerList || false;
            document.getElementById('roulette-classic-min').value = data.settings.classicMin;
            document.getElementById('roulette-classic-max').value = data.settings.classicMax;
            document.getElementById('roulette-challenges-min').value = data.settings.challengesMin;
            document.getElementById('roulette-challenges-max').value = data.settings.challengesMax;
            document.getElementById('roulette-platformer-min').value = data.settings.platformerMin || 1;
            document.getElementById('roulette-platformer-max').value = data.settings.platformerMax || 1000;
            document.getElementById('allow-repeats').checked = data.settings.allowRepeats;
            document.getElementById('skip-count').value = data.settings.skipCount || 0;
            document.getElementById('skip-adds-percent').checked = data.settings.skipAddsPercent !== undefined ? 
                data.settings.skipAddsPercent : true;
            document.getElementById('filter-unrated').checked = data.settings.filterUnrated || false;
            document.getElementById('filter-2player').checked = data.settings.filter2Player || false;
            document.getElementById('max-plus-one').checked = data.settings.maxPlusOne !== undefined ? 
                data.settings.maxPlusOne : false;

            // Загружаем историю
            rouletteState.history = data.history.map(item => {
                // Находим уровень в данных
                let level;
                if (item.listType === 'classic') {
                    level = levelData.classic.find(l => l.id === item.id) || levelData.classic[item.position - 1];
                } else if (item.listType === 'challenges') {
                    level = levelData.challenges.find(l => l.id === item.id) || levelData.challenges[item.position - 1];
                } 
                
                if (!level) {
                    throw new Error(`Level not found: ${item.title} (${item.listType} #${item.position})`);
                }
                
                return {
                    level: level,
                    position: item.position,
                    percentage: item.percentage
                };
            });
            
            // Загружаем текущий уровень, если он есть
            if (data.currentLevel) {
                let currentLevel;
                if (data.currentLevel.listType === 'classic') {
                    currentLevel = levelData.classic.find(l => l.id === data.currentLevel.id) || 
                                 levelData.classic[data.currentLevel.position - 1];
                } else if (data.currentLevel.listType === 'challenges') {
                    currentLevel = levelData.challenges.find(l => l.id === data.currentLevel.id) || 
                                   levelData.challenges[data.currentLevel.position - 1];
                } else if (data.currentLevel.listType === 'platformer') {
                    currentLevel = levelData.platformer.find(l => l.id === data.currentLevel.id) || 
                                  levelData.platformer[data.currentLevel.position - 1];
                }
                
if (currentLevel) {
    rouletteState.currentLevel = {
        level: currentLevel,
        position: data.currentLevel.position,
        listType: data.currentLevel.listType
    };
    
// Обновляем контейнер уровней с учетом минимального процента
const minPercentage = calculateMinPercentage();
const container = document.getElementById('roulette-levels-container');
container.innerHTML = generateRouletteLevelHTML(
    currentLevel, 
    data.currentLevel.position,
    data.currentLevel.listType,
    minPercentage // Передаем вычисленный минимальный процент
);
    
    // Устанавливаем процент, если он был
    if (data.currentLevel.percentage) {
        document.getElementById('percentage-input').value = data.currentLevel.percentage;
    }
    
    // Инициализируем ленивую загрузку изображений
    setupLazyLoading();
}
            }
            
            // Устанавливаем оставшиеся пропуски
            rouletteState.remainingSkips = data.remainingSkips || 0;
            rouletteState.skipAddsPercent = data.settings.skipAddsPercent !== undefined ? 
                data.settings.skipAddsPercent : true;
            
            // Обновляем отображение истории
            document.getElementById('history-container').innerHTML = generateHistoryHTML();
            
            // Запускаем рулетку
            rouletteState.active = true;
            rouletteState.allowRepeats = data.settings.allowRepeats;
            rouletteState.totalSkips = data.settings.skipCount || 0;
            document.getElementById('roulette-section').style.display = 'block';
            
            showCustomAlert('History imported successfully!', true);
        } catch (error) {
            showCustomAlert(`Import failed: ${error.message}`);
            console.error(error);
        }
    };
    
    reader.onerror = function() {
        showCustomAlert('Error reading file');
    };
    
    reader.readAsText(file);
}

    function showCustomAlert(message, isSuccess = false) {
      const alertBox = document.createElement('div');
      alertBox.style.position = 'fixed';
      alertBox.style.top = '20px';
      alertBox.style.left = '50%';
      alertBox.style.transform = 'translateX(-50%)';
      alertBox.style.backgroundColor = isSuccess ? '#4CAF50' : '#e94057';
      alertBox.style.color = 'white';
      alertBox.style.padding = '15px 25px';
      alertBox.style.borderRadius = '6px';
      alertBox.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
      alertBox.style.zIndex = '9999';
      alertBox.style.fontWeight = '600';
      alertBox.style.animation = 'fadeIn 0.3s ease-in-out';
      alertBox.textContent = message;
      
      document.body.appendChild(alertBox);
      
      setTimeout(() => {
        alertBox.style.animation = 'fadeOut 0.3s ease-in-out';
        setTimeout(() => {
          document.body.removeChild(alertBox);
        }, 300);
      }, 3000);
    }

    // Функция для отображения модального окна подтверждения
function showConfirmationModal(title, message, callback) {
  const modal = document.getElementById('confirm-modal');
  const modalTitle = document.getElementById('confirm-modal-title');
  const modalMessage = document.getElementById('confirm-modal-message');
const confirmBtn = document.getElementById('confirm-modal-ok');
const cancelBtn = document.getElementById('confirm-modal-cancel');
const closeBtn = document.getElementById('confirm-modal-close');
  
  // Устанавливаем текст
  modalTitle.textContent = title;
  modalMessage.textContent = message;
  
  // Показываем модальное окно
  modal.style.display = 'flex';
  setTimeout(() => {
    modal.classList.add('active');
  }, 10);
  
  // Обработчики событий
  const handleConfirm = () => {
    callback();
    hideConfirmationModal();
  };
  
  const hideConfirmationModal = () => {
    document.removeEventListener('keydown', handleEsc);
    modal.classList.remove('active');
    setTimeout(() => {
      modal.style.display = 'none';
    }, 300);
    
    // Удаляем обработчики
    confirmBtn.removeEventListener('click', handleConfirm);
    cancelBtn.removeEventListener('click', hideConfirmationModal);
  };
  
  // Закрытие по Esc
  const handleEsc = (e) => {
    if (e.key === 'Escape') {
      hideConfirmationModal();
      document.removeEventListener('keydown', handleEsc);
    }
  };
  document.addEventListener('keydown', handleEsc);
  
  confirmBtn.addEventListener('click', handleConfirm);
  cancelBtn.addEventListener('click', hideConfirmationModal);
  closeBtn.addEventListener('click', hideConfirmationModal);
}

    // Функция для ленивой загрузки изображений
    function setupLazyLoading() {
      const lazyImages = [].slice.call(document.querySelectorAll('img[data-src]'));
      
      if ('IntersectionObserver' in window) {
        const lazyImageObserver = new IntersectionObserver(function(entries, observer) {
          entries.forEach(function(entry) {
            if (entry.isIntersecting) {
              const lazyImage = entry.target;
              lazyImage.src = lazyImage.dataset.src;
              lazyImage.classList.add('loaded');
              lazyImageObserver.unobserve(lazyImage);
            }
          });
        });

        lazyImages.forEach(function(lazyImage) {
          lazyImageObserver.observe(lazyImage);
        });
      } else {
        // Fallback для браузеров без IntersectionObserver
        lazyImages.forEach(function(lazyImage) {
          lazyImage.src = lazyImage.dataset.src;
        });
      }
    }

    // Функция для фильтрации уровней
function filterLevels() {
    const searchTerm = document.getElementById('search-input').value.toLowerCase();
    const classicList = document.getElementById('classic-list');
    const challengesList = document.getElementById('challenges-list');
    const platformerList = document.getElementById('platformer-list');
    
    let levels, container;
    if (classicList.style.display !== 'none') {
        levels = classicList.querySelectorAll('.level');
        container = classicList;
    } else if (challengesList.style.display !== 'none') {
        levels = challengesList.querySelectorAll('.level');
        container = challengesList;
    } else {
        levels = platformerList.querySelectorAll('.level');
        container = platformerList;
    }
    
    const hasSearchTerm = searchTerm.length > 0;
    container.classList.toggle('search-active', hasSearchTerm);
    
    // Получаем текущие настройки фильтров
    const filterUnrated = document.getElementById('filter-unrated-levels').checked;
    const filter2Player = document.getElementById('filter-2player-levels').checked;
    const filterInvisible = document.getElementById('filter-invisible-levels').checked;
    const filterChallenges = document.getElementById('filter-challenges-levels').checked;
    
    levels.forEach(level => {
        const title = level.querySelector('.level-title').textContent.toLowerCase();
        const levelId = level.querySelector('.level-id').textContent;
        
        // Определяем тип текущего списка
        let listType;
        if (classicList.style.display !== 'none') {
            listType = 'classic';
        } else if (challengesList.style.display !== 'none') {
            listType = 'challenges';
        } else {
            listType = 'platformer';
        }
        
        // Находим данные уровня
        const levelDataItem = levelData[listType].find(l => l.id === levelId);
        
        // Проверяем, не отфильтрован ли уровень
        let isFiltered = false;
        
        if (levelDataItem) {
            // Применяем фильтр Unrated
            if (filterUnrated && levelDataItem.tags && levelDataItem.tags.includes("Unrated")) {
                isFiltered = true;
            }
            
            // Применяем фильтр 2-Player
            if (filter2Player && levelDataItem.tags && levelDataItem.tags.includes("2Player")) {
                isFiltered = true;
            }
            
            // Применяем фильтр Invisible
            if (filterInvisible && levelDataItem.tags && levelDataItem.tags.includes("Invisible")) {
                isFiltered = true;
            }
            
            // Применяем фильтр Challenges (длительность ≤ 29 секунд)
            if (filterChallenges && levelDataItem.lenght) {
                const durationSeconds = parseDurationToSeconds(levelDataItem.lenght);
                if (durationSeconds <= 29) {
                    isFiltered = true;
                }
            }
        }
        
        // Если уровень отфильтрован, скрываем его независимо от поискового запроса
        if (isFiltered) {
            level.style.display = 'none';
            return;
        }
        
        // Проверяем соответствие поисковому запросу
        let matches = false;
        
        if (searchMode === 'contains') {
            matches = title.includes(searchTerm);
        } else {
            // Убираем номер позиции (#1 - LevelName -> levelname)
            const cleanTitle = title.replace(/^#\d+\s-\s/, '');
            matches = cleanTitle.startsWith(searchTerm);
        }
        
        level.style.display = matches ? 'flex' : 'none';
    });
}

    // Функция для прокрутки к уровню
function scrollToLevel(button) {
  const level = button.closest('.level');
  document.getElementById('search-input').value = '';
  filterLevels();
  level.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

    // Функция копирования в буфер обмена
function copyToClipboard(element, text) {
  // Проверяем, находится ли элемент внутри рулетки
  const isInRoulette = element.closest('.roulette-level-stat-value') !== null;
  
  navigator.clipboard.writeText(text).then(() => {
    if (!isInRoulette) {
      const originalText = element.textContent;
      element.textContent = 'Copied!';
      setTimeout(() => {
        element.textContent = originalText;
      }, 2000);
    }
  }).catch(err => console.error('Failed to copy text: ', err));
}

function filterLevelsByDate(date) {
    // Определяем текущий активный список
    let currentList;
    if (document.getElementById('classic-list').style.display !== 'none') {
        currentList = 'classic';
    } else if (document.getElementById('challenges-list').style.display !== 'none') {
        currentList = 'challenges';
    } else {
        currentList = 'platformer';
    }
    
    const allLevels = levelData[currentList];
    
    // Получаем текущие настройки фильтров
    const filterUnrated = document.getElementById('filter-unrated-levels').checked;
    const filter2Player = document.getElementById('filter-2player-levels').checked;
    const filterInvisible = document.getElementById('filter-invisible-levels').checked;
    const filterChallenges = document.getElementById('filter-challenges-levels').checked;
    
    // Фильтруем уровни, выпущенные до или в выбранную дату + применяем фильтры
    const filteredLevels = allLevels.filter(level => {
        if (!level.releaseDate) return false;
        
        // Проверяем дату
        if (new Date(level.releaseDate) > date) return false;
        
        // Применяем фильтр Unrated
        if (filterUnrated && level.tags && level.tags.includes("Unrated")) {
            return false;
        }
        
        // Применяем фильтр 2-Player
        if (filter2Player && level.tags && level.tags.includes("2Player")) {
            return false;
        }
        
        // Применяем фильтр Invisible
        if (filterInvisible && level.tags && level.tags.includes("Invisible")) {
            return false;
        }
        
        // Применяем фильтр Challenges (длительность ≤ 29 секунд)
        if (filterChallenges && level.lenght) {
            const durationSeconds = parseDurationToSeconds(level.lenght);
            if (durationSeconds <= 29) {
                return false;
            }
        }
        
        return true;
    });
    
    // Сортируем по позиции в оригинальном списке
    filteredLevels.sort((a, b) => {
        const posA = allLevels.findIndex(l => l.id === a.id) + 1;
        const posB = allLevels.findIndex(l => l.id === b.id) + 1;
        return posA - posB;
    });
    
    const container = document.getElementById(`${currentList}-list`);
    container.innerHTML = '';
    
    // Генерируем HTML с новыми позициями и учетом Former #1 с фильтрами
    filteredLevels.forEach((level, index) => {
        const newPosition = index + 1;
        
        // Проверяем был ли уровень на первом месте с учетом фильтров
        const isFormerFirstPlace = wasFirstPlaceOnRelease(level, currentList, filterUnrated, filter2Player, filterInvisible, filterChallenges);
        
        let titleColorClass = '';
        if (!level.lenght && !level.previewImg) {
            // Нет ни lenght, ни previewImg - оставляем стандартный цвет
        } else if (!level.lenght) {
            // Нет lenght - оранжевый
            titleColorClass = 'no-length-title';
        } else if (level.previewImg) {
            // Есть previewImg - желтый
            titleColorClass = 'has-preview-title';
        }
        
        if (!level.lenght && level.previewImg) {
            titleColorClass = 'no-length-has-preview-title';
        }
        
        const previewUrl = level.previewImg 
            ? level.previewImg 
            : `images/${level.id}.png`;
        
        const isNewLevel = isLevelNew(level.releaseDate);
        
        container.innerHTML += `
            <div class="level ${!level.lenght ? 'no-length-level' : ''}">
                <div class="level-preview">
                    <a href="${level.videoUrl}" target="_blank">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiA5Ii8+" 
                             data-src="${previewUrl}" 
                             alt="Level Preview" 
                             loading="lazy" 
                             width="400" 
                             height="225">
                    </a>
                </div>
                <div class="level-info">
                    <h2 class="level-title ${titleColorClass}">#${newPosition} - ${level.title}</h2>
                    <p class="level-author">Published by ${level.author}</p>
                    <p class="level-verifier">Verified by ${level.verifier}</p>
                </div>
                ${isNewLevel ? '<div class="level-new-container" title="New Level (Verified in last 30 days)"><img src="images/new_label.png" alt="NEW"></div>' : ''}
                ${isFormerFirstPlace ? '<div class="level-crown-container" title="Former Hardest Level"><img src="images/Crown.png" alt="👑" style="width: 100%; height: 100%; object-fit: contain;"></div>' : ''}
                <div class="show-in-list" onclick="scrollToLevel(this)">Show in List</div>
                <div class="level-id" onclick="copyToClipboard(this, '${level.id}')">${level.id}</div>
            </div>
        `;
    });
    
    setupLazyLoading();
    showCustomAlert(`Showing top ${filteredLevels.length} ${currentList} levels as of ${date.toLocaleDateString()}`, true);
}

// Основной скрипт
document.addEventListener('DOMContentLoaded', function() {
    // Сначала объявляем все переменные для элементов DOM
    const searchModeBtn = document.getElementById('search-mode-btn');
    const currentListBtn = document.getElementById('current-list-btn');
    const classicList = document.getElementById('classic-list');
    const challengesList = document.getElementById('challenges-list');
    const platformerList = document.getElementById('platformer-list');
    const searchInput = document.getElementById('search-input');
    const dropdownLinks = document.querySelectorAll('.dropdown-content a');
    const scrollToTopBtn = document.querySelector('.scroll-to-top');
    const viewToggleBtn = document.getElementById('view-toggle-btn');
    
    // Demon Roulette элементы
    const rouletteBtn = document.getElementById('roulette-btn');
    const rouletteModal = document.getElementById('roulette-modal');
    const modalClose = document.getElementById('modal-close');
    const spinBtn = document.getElementById('spin-btn');
    const endRouletteBtn = document.getElementById('roulette-end-btn');
    const exportRouletteBtn = document.getElementById('roulette-export-btn');
    const importRouletteBtn = document.getElementById('roulette-import-btn');
    const importFileInput = document.getElementById('import-file');
    
    // Time Machine элементы
    const timeMachineBtn = document.getElementById('time-machine-btn');
    const timeMachineModal = document.querySelector('.time-machine-modal');
    const timeMachineClose = document.getElementById('time-machine-close');
    const timeMachineApply = document.getElementById('time-machine-apply');
    const timeMachineInput = document.getElementById('time-machine-input');
    
    // Проверяем, что все основные элементы существуют
    if (!classicList || !challengesList || !platformerList) {
        console.error('Critical elements not found!');
        return;
    }

// Функция для применения фильтров
function applyFilters(showAlert = true) {
    const filterUnrated = document.getElementById('filter-unrated-levels').checked;
    const filter2Player = document.getElementById('filter-2player-levels').checked;
    const filterInvisible = document.getElementById('filter-invisible-levels').checked;
    const filterChallenges = document.getElementById('filter-challenges-levels').checked;
    
    // Сохраняем настройки фильтров
    saveToLocalStorage('filterUnratedLevels', filterUnrated);
    saveToLocalStorage('filter2PlayerLevels', filter2Player);
    saveToLocalStorage('filterInvisibleLevels', filterInvisible);
    saveToLocalStorage('filterChallengesLevels', filterChallenges);
    
    // Применяем фильтры ко всем спискам
    ['classic', 'challenges', 'platformer'].forEach(listType => {
        const container = document.getElementById(`${listType}-list`);
        const levels = container.querySelectorAll('.level');
        
        let visibleCount = 0;
        
        levels.forEach(level => {
            const levelId = level.querySelector('.level-id').textContent;
            const levelDataItem = levelData[listType].find(l => l.id === levelId);
            
            let shouldShow = true;
            
            // Фильтр Unrated уровней
            if (filterUnrated && levelDataItem && levelDataItem.tags && levelDataItem.tags.includes("Unrated")) {
                shouldShow = false;
            }
            
            // Фильтр 2-Player уровней
            if (filter2Player && levelDataItem && levelDataItem.tags && levelDataItem.tags.includes("2Player")) {
                shouldShow = false;
            }
            
            // Фильтр Invisible уровней
            if (filterInvisible && levelDataItem && levelDataItem.tags && levelDataItem.tags.includes("Invisible")) {
                shouldShow = false;
            }
            
            // Фильтр Challenges (длительность ≤ 29 секунд)
            if (filterChallenges && levelDataItem && levelDataItem.lenght) {
                const durationSeconds = parseDurationToSeconds(levelDataItem.lenght);
                if (durationSeconds <= 29) {
                    shouldShow = false;
                }
            }
            
            // ВАЖНО: Всегда показываем превью, даже если уровень скрыт
            const previewImg = level.querySelector('.level-preview img');
            if (previewImg && previewImg.dataset.src) {
                previewImg.src = previewImg.dataset.src;
                previewImg.classList.add('loaded');
            }
            
            level.style.display = shouldShow ? 'flex' : 'none';
            
            if (shouldShow) {
                visibleCount++;
                
                // Обновляем позицию
                const titleElement = level.querySelector('.level-title');
                titleElement.textContent = titleElement.textContent.replace(/^#\d+/, `#${visibleCount}`);
                
                // Пересчитываем иконку Former #1 с учетом фильтров
                const hasCrown = wasFirstPlaceOnRelease(levelDataItem, listType, filterUnrated, filter2Player, filterInvisible, filterChallenges);
                const crownContainer = level.querySelector('.level-crown-container');
                
                if (hasCrown && !crownContainer) {
                    level.innerHTML += '<div class="level-crown-container" title="Former Hardest Level"><img src="images/Crown.png" alt="👑" style="width: 100%; height: 100%; object-fit: contain;"></div>';
                } else if (!hasCrown && crownContainer) {
                    crownContainer.remove();
                }
            }
        });
    });
    
    // Перезагружаем изображения после применения фильтров
    setTimeout(() => {
        setupLazyLoading();
    }, 100);
    
    // Показываем сообщение только если явно указано
    if (showAlert) {
        showCustomAlert('Filters applied successfully!', true);
    }
}

// Функция для сброса фильтров
function resetFilters() {
    // Сбрасываем состояние фильтров
    document.getElementById('filter-unrated-levels').checked = false;
    document.getElementById('filter-2player-levels').checked = false;
    document.getElementById('filter-invisible-levels').checked = false;
    document.getElementById('filter-challenges-levels').checked = false;
    
    // Сохраняем настройки
    saveToLocalStorage('filterUnratedLevels', false);
    saveToLocalStorage('filter2PlayerLevels', false);
    saveToLocalStorage('filterInvisibleLevels', false);
    saveToLocalStorage('filterChallengesLevels', false);
    
    // Перерисовываем уровни без фильтров
    renderLevels('classic');
    renderLevels('challenges');
    renderLevels('platformer');
    
    // Восстанавливаем активный список
    const activeList = localStorage.getItem('activeList') || 'classic';
    document.querySelector(`.dropdown-content a[data-list="${activeList}"]`).click();
    
    showCustomAlert('Filters reset successfully!', true);
}

// Функция для проверки, был ли уровень на первом месте при выходе с учетом фильтров
function wasFirstPlaceOnRelease(level, listType, filterUnrated = false, filter2Player = false, filterInvisible = false, filterChallenges = false) {
    const releaseDate = new Date(level.releaseDate);
    if (isNaN(releaseDate.getTime())) return false;
    
    // Находим индекс текущего уровня в списке
    const levelIndex = levelData[listType].findIndex(l => l.id === level.id);
    if (levelIndex === -1) return false;
    
    // Находим все уровни, выпущенные до или в тот же день, кроме исключений
    const levelsBefore = levelData[listType].filter(l => {
        if (!l.releaseDate) return false;
        
        // Применяем фильтр Unrated
        if (filterUnrated && l.tags && l.tags.includes("Unrated")) {
            return false;
        }
        
        // Применяем фильтр 2-Player
        if (filter2Player && l.tags && l.tags.includes("2Player")) {
            return false;
        }
        
        // Применяем фильтр Invisible
        if (filterInvisible && l.tags && l.tags.includes("Invisible")) {
            return false;
        }
        
        // Применяем фильтр Challenges (длительность ≤ 29 секунд)
        if (filterChallenges && l.lenght) {
            const durationSeconds = parseDurationToSeconds(l.lenght);
            if (durationSeconds <= 29) {
                return false;
            }
        }
        
        // Игнорируем Amethyst только для Thinking Space II
        if (level.title === "Thinking Space II" && l.title === "Amethyst") {
            return false;
        }
        
        // Игнорируем Silent clubstep для Acheron и Acheron buffed
        const isAcheronGroup = ["Acheron", "Acheron buffed"].includes(level.title);
        if (isAcheronGroup && l.title === "Silent clubstep") {
            return false;
        }
        
        const lDate = new Date(l.releaseDate);
        return lDate <= releaseDate;
    });
    
    // Если нет других уровней или наш уровень самый старый
    if (levelsBefore.length === 0) return false;
    
    // Сортируем по позиции в списке (чем выше позиция - тем сложнее уровень)
    const sortedByPosition = [...levelsBefore].sort((a, b) => {
        const posA = levelData[listType].indexOf(a) + 1;
        const posB = levelData[listType].indexOf(b) + 1;
        return posA - posB;
    });
    
    // Самый сложный уровень среди выпущенных до или в тот же день
    const hardestLevel = sortedByPosition[0];
    
    // Проверяем, является ли наш уровень самым сложным среди выпущенных в этот день
    return hardestLevel.id === level.id;
}
    
    // Функция для инициализации приложения
function initializeApp() {
    // Сначала загружаем все настройки
    loadAllSettings();
    
    // Затем рендерим уровни
    renderLevels('classic');
    renderLevels('challenges');
    renderLevels('platformer');
    
    // Проверяем дубликаты ID
    checkForDuplicateIds();
    
    // Устанавливаем обработчики событий
    setupEventHandlers();
    
    // Восстанавливаем активный список
    const activeList = localStorage.getItem('activeList') || 'classic';
    document.querySelector(`.dropdown-content a[data-list="${activeList}"]`).click();
    
// Применяем фильтры после полной загрузки и рендеринга
const filterUnratedLevels = loadFromLocalStorage('filterUnratedLevels');
const filter2PlayerLevels = loadFromLocalStorage('filter2PlayerLevels');
const filterInvisibleLevels = loadFromLocalStorage('filterInvisibleLevels');
const filterChallengesLevels = loadFromLocalStorage('filterChallengesLevels');

if (filterUnratedLevels || filter2PlayerLevels || filterInvisibleLevels || filterChallengesLevels) {
    // Небольшая задержка для гарантии полного рендеринга
    setTimeout(() => {
        applyFilters(false); // false - не показывать сообщение
    }, 100);
}
    
    // Инициализируем ленивую загрузку
    setupLazyLoading();
}
    
    // Функция для установки всех обработчиков событий
    function setupEventHandlers() {
        // Поиск
        searchInput.addEventListener('input', filterLevels);
        
        // Кнопка "Наверх"
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.classList.add('visible');
            } else {
                scrollToTopBtn.classList.remove('visible');
            }
        });
        
        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // Режим поиска
        searchModeBtn.addEventListener('click', () => {
            searchMode = searchMode === 'contains' ? 'startsWith' : 'contains';
            searchModeBtn.innerHTML = searchMode === 'contains' 
                ? '<i class="fas fa-font"></i>' 
                : '<i class="fas fa-text-width"></i>';
            searchModeBtn.title = searchMode === 'contains' ? 'Contains mode' : 'Starts with mode';
            filterLevels();
            saveToLocalStorage('searchMode', searchMode);
        });
        
        // Переключение вида
        viewToggleBtn.addEventListener('click', () => {
            classicList.classList.toggle('compact-view');
            challengesList.classList.toggle('compact-view');
            platformerList.classList.toggle('compact-view');
            
            if (classicList.classList.contains('compact-view')) {
                viewToggleBtn.innerHTML = '<i class="fas fa-th-list"></i> Normal View';
            } else {
                viewToggleBtn.innerHTML = '<i class="fas fa-th-large"></i> Compact View';
            }
            
            saveToLocalStorage('compactView', classicList.classList.contains('compact-view'));
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
// Dropdown меню
const dropbtn = document.getElementById('current-list-btn');
const dropdownContent = document.getElementById('dropdown-content');
const dropdownLinks = document.querySelectorAll('.dropdown-content a');

// Обработчик клика по кнопке
dropbtn.addEventListener('click', function(e) {
  e.stopPropagation();
  dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
});

// Закрытие при клике вне dropdown
document.addEventListener('click', function() {
  dropdownContent.style.display = 'none';
});

// Обработчики для ссылок dropdown
dropdownLinks.forEach(link => {
  link.addEventListener('click', function(e) {
    e.preventDefault();
    const listType = this.getAttribute('data-list');
    
    classicList.style.display = listType === 'classic' ? 'flex' : 'none';
    challengesList.style.display = listType === 'challenges' ? 'flex' : 'none';
    platformerList.style.display = listType === 'platformer' ? 'flex' : 'none';
    
    localStorage.setItem('activeList', listType);
    filterLevels();
    
    dropdownContent.style.display = 'none';
  });
});

// Players button handler
document.getElementById('players-btn').addEventListener('click', () => {
  window.location.href = 'players.html';
});
        
        // Demon Roulette обработчики
        rouletteBtn.addEventListener('click', () => {
            rouletteModal.style.display = 'flex';
            setTimeout(() => {
                rouletteModal.classList.add('active');
            }, 10);
        });
        
        modalClose.addEventListener('click', () => {
            rouletteModal.classList.remove('active');
            setTimeout(() => {
                rouletteModal.style.display = 'none';
            }, 300);
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && rouletteModal.classList.contains('active')) {
                rouletteModal.classList.remove('active');
                setTimeout(() => {
                    rouletteModal.style.display = 'none';
                }, 300);
            }
        });
        
spinBtn.addEventListener('click', (e) => {
    e.preventDefault();
    
    // Проверяем, что хотя бы один список выбран
    const classicChecked = document.getElementById('roulette-classic').checked;
    const challengesChecked = document.getElementById('roulette-challenges').checked;
    
    if (!classicChecked && !challengesChecked) {
        showCustomAlert('Please select at least one list!');
        return;
    }

    // Закрываем модальное окно
    rouletteModal.classList.remove('active');
    setTimeout(() => {
        rouletteModal.style.display = 'none';
        
        // Запускаем рулетку после закрытия окна
        try {
            startRoulette();
        } catch (error) {
            console.error('Error starting roulette:', error);
            showCustomAlert('Failed to start roulette. Please check console for details.');
        }
    }, 300);
});
        
        endRouletteBtn.addEventListener('click', () => {
            showConfirmationModal(
                'End Roulette', 
                'Are you sure you want to end the roulette and clear its history? This action cannot be undone.',
                () => {
                    clearRouletteHistory();
                    endRoulette();
                }
            );
        });
        
        exportRouletteBtn.addEventListener('click', exportRouletteData);
        importRouletteBtn.addEventListener('click', () => {
            importFileInput.click();
        });
        
        document.getElementById('enable-skips').addEventListener('change', function() {
            const skipInput = document.getElementById('skip-count');
            skipInput.disabled = !this.checked;
            if (this.checked && !skipInput.value) {
                skipInput.value = '3';
            }
        });
        
        importFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importRouletteData(e.target.files[0]);
                e.target.value = '';
            }
        });

        // Filters button handlers
const filtersBtn = document.getElementById('filters-btn');
const filtersModal = document.getElementById('filters-modal');
const filtersClose = document.getElementById('filters-modal-close');
const filtersApply = document.getElementById('filters-apply-btn');

filtersBtn.addEventListener('click', () => {
    // Синхронизируем состояние чекбокса с текущими настройками
    const filterUnratedLevels = loadFromLocalStorage('filterUnratedLevels');
    document.getElementById('filter-unrated-levels').checked = filterUnratedLevels !== null ? filterUnratedLevels : false;
    
    filtersModal.style.display = 'flex';
    setTimeout(() => {
        filtersModal.classList.add('active');
    }, 10);
});

filtersClose.addEventListener('click', () => {
    filtersModal.classList.remove('active');
    setTimeout(() => {
        filtersModal.style.display = 'none';
    }, 300);
});

filtersApply.addEventListener('click', () => {
    // Получаем новое состояние чекбокса
    const newFilterState = document.getElementById('filter-unrated-levels').checked;
    
    // Сохраняем настройки
    saveToLocalStorage('filterUnratedLevels', newFilterState);
    
    // Применяем фильтры
    applyFilters();
    
    // Закрываем модальное окно
    filtersModal.classList.remove('active');
    setTimeout(() => {
        filtersModal.style.display = 'none';
    }, 300);
});
        
        // Time Machine обработчики
        timeMachineBtn.addEventListener('click', () => {
            timeMachineModal.style.display = 'flex';
            setTimeout(() => {
                timeMachineModal.classList.add('active');
                timeMachineInput.focus();
                
                const handleEsc = (e) => {
                    if (e.key === 'Escape') closeTimeMachineModal();
                };
                document.addEventListener('keydown', handleEsc);
                timeMachineModal._escHandler = handleEsc;
            }, 10);
        });
        
        timeMachineClose.addEventListener('click', closeTimeMachineModal);
        timeMachineModal.addEventListener('click', (e) => {
            if (e.target === timeMachineModal) closeTimeMachineModal();
        });
        
        timeMachineApply.addEventListener('click', () => {
            const dateStr = timeMachineInput.value;
            if (!dateStr) {
                showCustomAlert('Please enter a date!');
                return;
            }
            const selectedDate = new Date(dateStr);
            filterLevelsByDate(selectedDate);
            closeTimeMachineModal();
            saveToLocalStorage('lastTimeMachineDate', timeMachineInput.value);
        });
    }
    
    function closeTimeMachineModal() {
        if (timeMachineModal._escHandler) {
            document.removeEventListener('keydown', timeMachineModal._escHandler);
        }
        timeMachineModal.classList.remove('active');
        setTimeout(() => {
            timeMachineModal.style.display = 'none';
        }, 300);
    }

            // Глобальные обработчики для событий рулетки
document.addEventListener('click', function(e) {
    // Используем closest для динамических элементов
    if (e.target.closest('#submit-percentage')) {
        submitPercentage();
    }
    if (e.target.closest('#skip-level')) {
        skipLevel();
    }
});

document.addEventListener('keydown', function(e) {
    if (e.target.closest('#percentage-input') && e.key === 'Enter') {
        e.preventDefault();
        submitPercentage();
    }
});
    
    // Запускаем инициализацию
    initializeApp();
});

// Обработчик для кнопки сброса фильтров
document.getElementById('filters-reset-btn').addEventListener('click', () => {
    resetFilters();
    filtersModal.classList.remove('active');
    setTimeout(() => {
        filtersModal.style.display = 'none';
    }, 300);
});

  </script>
  
<!-- Модальное окно подтверждения -->
<div class="modal" id="confirm-modal">
  <div class="modal-content" style="max-width: 400px;">
    <button class="modal-close" id="confirm-modal-close" style="
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    ">
      <i class="fas fa-times" style="font-size: 1.2em;"></i>
    </button>
    <div class="modal-header">
      <h2 class="modal-title" id="confirm-modal-title">Confirm Action</h2>
    </div>
    <div class="modal-body">
      <p id="confirm-modal-message">Are you sure you want to perform this action?</p>
    </div>
    <div class="modal-footer" style="display: flex; justify-content: space-between; margin-top: 20px;">
      <button class="modal-btn" id="confirm-modal-cancel" style="background: #555; flex: 1; margin-right: 10px;">Cancel</button>
      <button class="modal-btn" id="confirm-modal-ok" style="flex: 1;">Confirm</button>
    </div>
  </div>
</div>

<!-- Модальное окно Time Machine -->
<div class="time-machine-modal" id="time-machine-modal">
  <div class="time-machine-content">
    <button class="modal-close" id="time-machine-close">&times;</button>
    <div class="time-machine-header">
      <h2 class="time-machine-title">Time Machine</h2>
    </div>
    <div class="time-machine-body">
      <input type="date" id="time-machine-input" class="time-machine-input" placeholder="DD.MM.YYYY">
      <p style="color: #ccc; font-size: 0.9em; margin-top: 5px;">Enter date to see levels released on or before this date</p>
    </div>
    <div class="time-machine-footer">
      <button class="modal-btn" id="time-machine-apply">Apply</button>
    </div>
  </div>
</div>

<!-- Модальное окно Filters -->
<div class="modal" id="filters-modal">
  <div class="modal-content" style="max-width: 450px;">
    <button class="modal-close" id="filters-modal-close">
      <i class="fas fa-times"></i>
    </button>
    <div class="modal-header">
      <h2 class="modal-title">Filters</h2>
    </div>
    <div class="modal-body">
      <div class="filter-group">
        <label class="roulette-checkbox-label">
          <input type="checkbox" id="filter-unrated-levels">
          <span class="roulette-checkbox-custom"></span>
          <span>Filter Unrated Levels</span>
        </label>
      </div>
      <div class="filter-group">
        <label class="roulette-checkbox-label">
          <input type="checkbox" id="filter-2player-levels">
          <span class="roulette-checkbox-custom"></span>
          <span>Filter 2-Player Levels</span>
        </label>
      </div>
      <div class="filter-group">
        <label class="roulette-checkbox-label">
          <input type="checkbox" id="filter-invisible-levels">
          <span class="roulette-checkbox-custom"></span>
          <span>Filter Invisible Levels</span>
        </label>
      </div>
      <div class="filter-group">
        <label class="roulette-checkbox-label">
          <input type="checkbox" id="filter-challenges-levels">
          <span class="roulette-checkbox-custom"></span>
          <span>Filter Challenges (≤29s)</span>
        </label>
      </div>
    </div>
    <div class="modal-footer" style="display: flex; gap: 10px;">
      <button class="modal-btn" id="filters-apply-btn" style="flex: 1;">Apply Filters</button>
    </div>
  </div>
</div>

</body>
</html>